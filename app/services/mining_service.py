import os
import json
import uuid
import subprocess
import shutil
from ..config.settings import Config

class MiningService:
    @staticmethod
    def run_miner(input_file_path, job_id=None, **kwargs):
        """
        Runs the subgraph miner on the given input file.
        Returns the parsed JSON results and file paths.
        """
        if job_id is None:
            job_id = str(uuid.uuid4())
        
        shared_job_dir = "/shared/output/{}".format(job_id)
        os.makedirs(shared_job_dir, exist_ok=True)
        
        out_filename = str(uuid.uuid4()) + '.pkl'
        out_path = os.path.join(Config.RESULTS_FOLDER, out_filename)
        json_path = os.path.join(Config.RESULTS_FOLDER, out_filename.replace('.pkl', '.json'))
        
        # Instance files generated by decoder.py
        instance_json_path = os.path.join(Config.RESULTS_FOLDER, out_filename.replace('.pkl', '_all_instances.json'))
        instance_pkl_path = os.path.join(Config.RESULTS_FOLDER, out_filename.replace('.pkl', '_all_instances.pkl'))

        try:
            # Build command dynamically
            cmd = [
                "python3", "-m", "subgraph_mining.decoder",
                "--dataset={}".format(input_file_path),
                "--out_path={}".format(out_path)
            ]
            
            # Map kwargs to command arguments
            if 'n_trials' in kwargs:
                cmd.append("--n_trials={}".format(kwargs['n_trials']))
            
            if 'min_pattern_size' in kwargs:
                cmd.append("--min_pattern_size={}".format(kwargs['min_pattern_size']))
                
            if 'max_pattern_size' in kwargs:
                cmd.append("--max_pattern_size={}".format(kwargs['max_pattern_size']))
            
            if 'graph_type' in kwargs:
                cmd.append("--graph_type={}".format(kwargs['graph_type']))
                
            if kwargs.get('node_anchored', True): # Default to true as it seems common
                cmd.append("--node_anchored")
                
            if kwargs.get('visualize_instances', False):
                cmd.append("--visualize_instances")
            
            print("Running command: {}".format(' '.join(cmd)), flush=True)
            print("Mining started - this may take several minutes...", flush=True)
            print("Job ID: {}".format(job_id), flush=True)
            
            # Use Popen to stream output in real-time
            import os as os_module
            env = os_module.environ.copy()
            env['PYTHONUNBUFFERED'] = '1'
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                env=env
            )
            
            # Stream output line by line
            for line in process.stdout:
                print(line.rstrip(), flush=True)
            
            process.wait()
            
            if process.returncode != 0:
                raise Exception("Miner failed with exit code {}".format(process.returncode))

            # Read the results
            if not os.path.exists(json_path):
                 raise Exception('Result file not found')

            with open(json_path, 'r') as f:
                mining_results = json.load(f)

            shared_results_dir = os.path.join(shared_job_dir, "results")
            shared_plots_dir = os.path.join(shared_job_dir, "plots")
            os.makedirs(shared_results_dir, exist_ok=True)
            os.makedirs(shared_plots_dir, exist_ok=True)
            
            # Copy basic pattern results to shared volume
            if os.path.exists(out_path):
                shutil.copy(out_path, os.path.join(shared_results_dir, "patterns.pkl"))
            if os.path.exists(json_path):
                shutil.copy(json_path, os.path.join(shared_results_dir, "patterns.json"))
            
            # Copy instance results to shared volume AND persistent local path
            persistent_results_dir = "/app/results"
            os.makedirs(persistent_results_dir, exist_ok=True)
            
            if os.path.exists(instance_json_path):
                # Copy to shared results for download
                shutil.copy(instance_json_path, os.path.join(shared_results_dir, "patterns_all_instances.json"))
                # Copy to persistent results for LLM
                shutil.copy(instance_json_path, os.path.join(persistent_results_dir, "patterns_all_instances.json"))
                
            if os.path.exists(instance_pkl_path):
                # Copy to shared results for download
                shutil.copy(instance_pkl_path, os.path.join(shared_results_dir, "patterns_all_instances.pkl"))
                # Copy to persistent results for LLM
                shutil.copy(instance_pkl_path, os.path.join(persistent_results_dir, "patterns_all_instances.pkl"))

            plots_cluster_dir = "/app/plots/cluster"
            if os.path.exists(plots_cluster_dir):
                # Using shutil.copytree to handle subdirectories recursively
                # We copy to a temporary sub-path then move items to avoid copytree destination error if dir exists
                for item in os.listdir(plots_cluster_dir):
                    s = os.path.join(plots_cluster_dir, item)
                    d = os.path.join(shared_plots_dir, item)
                    if os.path.isdir(s):
                        if os.path.exists(d):
                            shutil.rmtree(d)
                        shutil.copytree(s, d)
                    else:
                        shutil.copy2(s, d)
            
            print("Results saved to shared volume: {}".format(shared_job_dir), flush=True)
            
            return {
                "motifs": mining_results,
                "job_id": job_id,
                "results_path": "/shared/output/{}/results".format(job_id),
                "plots_path": "/shared/output/{}/plots".format(job_id)
            }

        finally:
            # Cleanup temporary output files
            # Note: We need to clean up instance files too
            if os.path.exists(out_path):
                os.remove(out_path)
            if os.path.exists(json_path):
                os.remove(json_path)
            if os.path.exists(instance_json_path):
                os.remove(instance_json_path)
            if os.path.exists(instance_pkl_path):
                os.remove(instance_pkl_path)
