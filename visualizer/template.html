<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Discovery Visualizer</title>
    <!-- Dependencies -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <style>
        :root {
            --bg-deep: #0d1117;
            --bg-card: #161b22;
            --border-card: #30363d;
            --text-main: #c9d1d9;
            --text-dim: #8b949e;
            --accent-violet: #8b5cf6;
            --accent-blue: #3b82f6;
            --card-shadow: 0 8px 24px rgba(0,0,0,0.5);
        }

        body { 
            margin: 0; 
            font-family: 'Inter', sans-serif; 
            background: var(--bg-deep); 
            color: var(--text-main); 
            overflow: hidden; 
            user-select: none;
        }

        #app { width: 100vw; height: 100vh; position: relative; }
        
        /* Subtle Background Grid */
        .background-grid {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: radial-gradient(circle, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: 0;
        }

        canvas { position: absolute; top: 0; left: 0; z-index: 1; cursor: grab; }
        canvas:active { cursor: grabbing; }

        /* UI Base Class */
        .ui-card {
            background: var(--bg-card);
            border: 1px solid var(--border-card);
            border-radius: 10px;
            box-shadow: var(--card-shadow);
            z-index: 100;
            position: absolute;
            backdrop-filter: blur(8px);
        }

        /* Top Title Card */
        .top-card {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 30px;
            text-align: center;
            min-width: 300px;
        }
        .top-card h1 { margin: 0; font-size: 15px; font-weight: 700; color: #fff; }
        .top-card p { margin: 2px 0 0; font-size: 11px; color: var(--text-dim); }

        /* Zoom Controls (Top Right) */
        .zoom-controls {
            right: 20px;
            top: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 110;
        }
        .zoom-btn {
            width: 36px;
            height: 36px;
            background: var(--bg-card);
            border: 1px solid var(--border-card);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .zoom-btn:hover { border-color: var(--text-main); background: #1f242c; }

        /* Right Panel Stack */
        .right-panel {
            top: 75px;
            right: 20px;
            width: 210px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .section { padding: 18px; }
        .section-title {
            font-size: 11px;
            font-weight: 800;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        .section-title::after { content: ''; flex: 1; height: 1px; background: var(--border-card); margin-left: 10px; }

        /* Legend Elements */
        .legend-list { display: flex; flex-direction: column; gap: 10px; margin-bottom: 18px; }
        .legend-item { display: flex; align-items: center; gap: 10px; font-size: 12px; }
        .swatch { width: 12px; height: 12px; border-radius: 3px; flex-shrink: 0; }
        .sub-header { font-size: 9px; font-weight: 700; color: var(--text-dim); opacity: 0.6; margin-bottom: 8px; }

        /* Toggle Button */
        .toggle-row { display: flex; align-items: center; justify-content: space-between; font-size: 12px; font-weight: 600; margin-bottom: 15px; }
        .switch { position: relative; width: 42px; height: 22px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; bottom: 0; left: 0; right: 0; background-color: #334155; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-blue); }
        input:checked + .slider:before { transform: translateX(20px); }

        /* Action Buttons */
        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .btn-action {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-card);
            color: #fff;
            padding: 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn-action:hover { background: rgba(255,255,255,0.1); border-color: var(--text-dim); }

        /* Chat Bubble (Violet) */
        .chat-trigger {
            position: absolute;
            bottom: 25px;
            left: 25px;
            width: 54px;
            height: 54px;
            background: var(--accent-violet);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
            z-index: 1000;
        }

        /* Pattern Analyser Window */
        .chat-container {
            position: absolute;
            bottom: 90px;
            left: 25px;
            width: 340px;
            height: 500px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid var(--border-card);
        }
        .chat-header {
            background: var(--accent-violet);
            color: white;
            padding: 14px 18px;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chat-main {
            flex: 1;
            background: #0d1117;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* API Key Field */
        .api-key-box {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-card);
            background: rgba(255,255,255,0.02);
        }
        .api-input {
            width: 100%;
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--border-card);
            border-radius: 4px;
            padding: 8px 12px;
            color: white;
            font-size: 11px;
            outline: none;
            box-sizing: border-box;
        }

        .messages-area {
            flex: 1;
            padding: 18px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .message-bubble { 
            padding: 10px 14px; 
            border-radius: 12px; 
            font-size: 13px; 
            line-height: 1.5; 
            max-width: 85%; 
        }
        .message-bubble.ai { background: rgba(255,255,255,0.05); border: 1px solid var(--border-card); align-self: flex-start; }
        .message-bubble.user { background: var(--accent-violet); color: white; align-self: flex-end; }

        .chat-input-bar {
            padding: 18px;
            border-top: 1px solid var(--border-card);
            display: flex;
            gap: 10px;
            background: #161b22;
        }
        .chat-field {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border-card);
            border-radius: 20px;
            padding: 8px 16px;
            color: white;
            font-size: 13px;
            outline: none;
        }
        .send-icon-btn {
            width: 36px;
            height: 36px;
            background: var(--accent-violet);
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
        }

        /* Vue Animations */
        .fade-slide-enter-active, .fade-slide-leave-active { transition: all 0.3s ease; }
        .fade-slide-enter-from, .fade-slide-leave-to { opacity: 0; transform: translateY(20px); }

        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-thumb { background: #30363d; border-radius: 10px; }
    </style>
</head>
<body>
    <div id="app">
        <div class="background-grid"></div>
        <canvas ref="canvasEl" @mousedown="startDrag" @mousemove="onDrag" @mouseup="endDrag" @wheel.prevent="onWheel"></canvas>
        
        <!-- Header Info -->
        <div class="ui-card top-card">
            <h1>{{ metadata.title }}</h1>
            <p>{{ metadata.nodeCount }} nodes ({{ legend.nodeTypes.length }} types), {{ metadata.edgeCount }} edges</p>
        </div>

        <!-- Zoom Controls -->
        <div class="zoom-controls">
            <button class="zoom-btn" @click="changeZoom(1.1)">+</button>
            <button class="zoom-btn" @click="changeZoom(0.9)">-</button>
            <button class="zoom-btn" @click="resetCamera">⌂</button>
        </div>

        <!-- Functional Sidebar -->
        <div class="right-panel">
            <!-- Legend Area -->
            <div class="ui-card section">
                <div class="section-title">Legend</div>
                <div class="sub-header">NODE TYPES</div>
                <div class="legend-list">
                    <div v-for="t in legend.nodeTypes" :key="t.label" class="legend-item">
                        <div class="swatch" :style="{ background: t.color }"></div>
                        <span>{{ t.label }}</span>
                    </div>
                </div>
                <div class="sub-header">EDGE TYPES</div>
                <div class="legend-list">
                    <div v-for="t in legend.edgeTypes" :key="t.label" class="legend-item">
                        <div class="swatch" :style="{ background: t.color }"></div>
                        <span>{{ t.label }}</span>
                    </div>
                </div>
                <div class="sub-header">SPECIAL NODES</div>
                <div class="legend-item">
                    <div class="swatch" style="background: #ef4444; border-radius: 2px;"></div>
                    <span>Anchor Nodes</span>
                </div>
            </div>

            <!-- Controls Area -->
            <div class="ui-card section">
                <div class="toggle-row">
                    <span>Show Labels</span>
                    <label class="switch">
                        <input type="checkbox" v-model="showLabels" @change="drawGraph">
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="section-title" style="margin-top: 20px;">Navigation</div>
                <div class="grid-buttons">
                    <button class="btn-action" @click="nav('http://localhost:3000/import')">Upload</button>
                    <button class="btn-action" @click="nav('http://localhost:3000')">Annotation</button>
                </div>

                <div class="section-title" style="margin-top: 20px;">Export</div>
                <div class="grid-buttons">
                    <button class="btn-action" @click="savePDF">PDF</button>
                    <button class="btn-action" @click="savePNG">PNG</button>
                </div>
            </div>
        </div>

        <!-- Floating Action Button -->
        <div class="chat-trigger" @click="openChat = !openChat">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
        </div>

        <!-- Pattern Analyser Module -->
        <transition name="fade-slide">
            <div v-if="openChat" class="ui-card chat-container">
                <div class="chat-header">
                    <span>Pattern Analyser</span>
                    <span @click="openChat = false" style="cursor: pointer; opacity: 0.6;">×</span>
                </div>
                <div class="chat-main">
                    <div class="api-key-box">
                        <input type="password" v-model="geminiApiKey" class="api-input" placeholder="Enter Gemini API Key">
                    </div>
                    <div class="messages-area" ref="scrollRef">
                        <div v-for="m in chats" :key="m.id" :class="['message-bubble', m.role]">
                            {{ m.text }}
                        </div>
                    </div>
                </div>
                <div class="chat-input-bar">
                    <input v-model="query" @keyup.enter="doChat" class="chat-field" placeholder="Ask about this pattern...">
                    <button class="send-icon-btn" @click="doChat">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    </button>
                </div>
            </div>
        </transition>
    </div>

    <script>
        // DATA INJECTION POINT
        const GRAPH_DATA = null;

        const { createApp, ref, onMounted, nextTick } = Vue;

        createApp({
            setup() {
                const canvasEl = ref(null);
                const scrollRef = ref(null);
                const openChat = ref(false);
                const showLabels = ref(true);
                const query = ref('');
                const geminiApiKey = ref('');
                
                const raw = GRAPH_DATA || {
                    metadata: { title: "Motif Analysis Results", nodeCount: 0, edgeCount: 0 },
                    nodes: [], edges: [], legend: { nodeTypes: [], edgeTypes: [] }
                };

                const metadata = ref(raw.metadata);
                const legend = ref(raw.legend);
                const chats = ref([
                    { id: 1, role: 'ai', text: "Hello! I'm your Pattern Analyst. I can help you understand the topological structure of this motif. Ask me anything!" }
                ]);

                let ctx, cam = { x: 0, y: 0, k: 1 };
                let mouse = { down: false, last: { x: 0, y: 0 } };

                const drawGraph = () => {
                    const canvas = canvasEl.value;
                    if (!canvas || !ctx) return;
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.save();
                    ctx.translate(canvas.width/2 + cam.x, canvas.height/2 + cam.y);
                    ctx.scale(cam.k, cam.k);

                    // Render Connections
                    raw.edges.forEach(e => {
                        const s = raw.nodes.find(n => n.id === e.source);
                        const t = raw.nodes.find(n => n.id === e.target);
                        if (!s || !t) return;

                        ctx.beginPath();
                        ctx.moveTo(s.x, s.y);
                        ctx.lineTo(t.x, t.y);
                        ctx.strokeStyle = '#4f46e5';
                        ctx.globalAlpha = 0.5;
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        if (e.directed) {
                            const angle = Math.atan2(t.y - s.y, t.x - s.x);
                            const r = t.anchor ? 24 : 16;
                            const ax = t.x - r * Math.cos(angle);
                            const ay = t.y - r * Math.sin(angle);
                            ctx.beginPath();
                            ctx.moveTo(ax, ay);
                            ctx.lineTo(ax - 10*Math.cos(angle - 0.4), ay - 10*Math.sin(angle - 0.4));
                            ctx.lineTo(ax - 10*Math.cos(angle + 0.4), ay - 10*Math.sin(angle + 0.4));
                            ctx.closePath();
                            ctx.fillStyle = '#4f46e5';
                            ctx.fill();
                        }
                        
                        if (showLabels.value && e.label && e.label !== 'default') {
                            drawLabel(e.label, (s.x+t.x)/2, (s.y+t.y)/2, 8, false);
                        }
                    });

                    // Render Components
                    raw.nodes.forEach(n => {
                        const r = n.anchor ? 22 : 14;
                        ctx.save();
                        ctx.shadowBlur = 12;
                        ctx.shadowColor = 'rgba(0,0,0,0.5)';
                        
                        ctx.beginPath();
                        if (n.anchor) {
                            ctx.roundRect(n.x - r, n.y - r, r*2, r*2, 4);
                        } else {
                            ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
                        }
                        
                        const color = n.anchor ? '#ef4444' : (legend.value.nodeTypes.find(t => t.label === n.label)?.color || '#3b82f6');
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        ctx.restore();

                        if (showLabels.value) {
                            drawLabel(n.label || 'Node', n.x, n.y + r + 16, 10, true);
                        }
                    });

                    ctx.restore();
                };

                const drawLabel = (text, x, y, size, isNode) => {
                    ctx.font = `bold ${size}px Inter`;
                    const w = ctx.measureText(text).width;
                    const p = 6;
                    
                    ctx.save();
                    ctx.fillStyle = isNode ? 'white' : 'rgba(22, 27, 34, 0.9)';
                    ctx.beginPath();
                    ctx.roundRect(x - w/2 - p, y - size/2 - p, w + p*2, size + p*2, 4);
                    ctx.fill();
                    
                    ctx.fillStyle = isNode ? '#161b22' : '#8b949e';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(text, x, y + 1);
                    ctx.restore();
                };

                const changeZoom = (f) => { cam.k *= f; drawGraph(); };
                const resetCamera = () => { cam = { x: 0, y: 0, k: 1 }; drawGraph(); };
                const startDrag = (e) => { mouse.down = true; mouse.last = { x: e.clientX, y: e.clientY }; };
                const endDrag = () => mouse.down = false;
                const onDrag = (e) => {
                    if (!mouse.down) return;
                    cam.x += (e.clientX - mouse.last.x);
                    cam.y += (e.clientY - mouse.last.y);
                    mouse.last = { x: e.clientX, y: e.clientY };
                    drawGraph();
                };
                const onWheel = (e) => {
                    const f = e.deltaY > 0 ? 0.9 : 1.1;
                    cam.k *= f;
                    drawGraph();
                };

                const doChat = async () => {
                    const t = query.value.trim();
                    if (!t) return;
                    chats.value.push({ id: Date.now(), role: 'user', text: t });
                    query.value = '';
                    
                    nextTick(() => { if(scrollRef.value) scrollRef.value.scrollTop = scrollRef.value.scrollHeight; });

                    try {
                        const res = await fetch('http://localhost:9002/chat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: t, graph_data: raw, api_key: geminiApiKey.value })
                        });
                        const data = await res.json();
                        chats.value.push({ id: Date.now(), role: 'ai', text: data.response || "No response." });
                    } catch (e) {
                        chats.value.push({ id: Date.now(), role: 'ai', text: "Error connecting to Pattern Analyst." });
                    }
                    nextTick(() => { if(scrollRef.value) scrollRef.value.scrollTop = scrollRef.value.scrollHeight; });
                };

                const savePDF = () => {
                    const doc = new window.jspdf.jsPDF('l', 'px', [canvasEl.value.width, canvasEl.value.height]);
                    doc.addImage(canvasEl.value.toDataURL('image/png'), 'PNG', 0, 0, canvasEl.value.width, canvasEl.value.height);
                    doc.save('graph.pdf');
                };

                const savePNG = () => {
                    const link = document.createElement('a');
                    link.download = 'graph.png';
                    link.href = canvasEl.value.toDataURL();
                    link.click();
                };

                const nav = (u) => window.open(u, '_blank');

                onMounted(() => {
                    const c = canvasEl.value;
                    c.width = window.innerWidth;
                    c.height = window.innerHeight;
                    ctx = c.getContext('2d');
                    window.addEventListener('resize', () => {
                        c.width = window.innerWidth;
                        c.height = window.innerHeight;
                        drawGraph();
                    });
                    drawGraph();
                });

                return {
                    canvasEl, scrollRef, openChat, showLabels, query, geminiApiKey, metadata, legend, chats,
                    changeZoom, resetCamera, startDrag, onDrag, endDrag, onWheel, doChat, savePDF, savePNG, nav, drawGraph
                };
            }
        }).mount('#app');
    </script>
</body>
</html>