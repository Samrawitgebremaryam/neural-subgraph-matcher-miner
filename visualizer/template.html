<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph Visualizer</title>
    <!-- Dependencies -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <style>
        :root {
            /* Color Palette - Light Theme */
            --bg-primary: oklch(0.96 0 0);
            --bg-secondary: oklch(0.97 0 0);
            --border-light: oklch(0.86 0 0);
            --text-primary: oklch(0.32 0 0);
            --text-secondary: oklch(0.51 0 0);
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* Dark Theme - Default */
        .dark {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --border-light: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --card-bg: #161b22;
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            --button-bg: #21262d;
            --button-hover: #30363d;
            --accent: #58a6ff;
        }

        body { 
            margin: 0; 
            font-family: 'Inter', system-ui, -apple-system, sans-serif; 
            background: var(--bg-primary); 
            color: var(--text-primary); 
            overflow: hidden; 
            user-select: none;
        }

        #app { width: 100vw; height: 100vh; position: relative; }
        
        /* Canvas */
        canvas { 
            position: absolute; top: 0; left: 0; z-index: 1; cursor: grab; 
            background-color: var(--bg-primary);
            background-image: radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.05) 1px, transparent 0);
            background-size: 20px 20px;
        }
        canvas:active { cursor: grabbing; }

        /* General UI Card */
        .ui-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            box-shadow: var(--card-shadow);
            z-index: 100;
            position: absolute;
            backdrop-filter: blur(10px);
            padding: 12px;
            color: var(--text-primary);
            font-size: 14px;
        }

        /* Top Center Title */
        .top-center {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            min-width: 300px;
        }
        .top-center h1 { margin: 0; font-size: 16px; font-weight: 600; color: var(--text-primary); }
        .top-center p { margin: 4px 0 0; font-size: 12px; color: var(--text-secondary); }

        /* Top Right: Zoom Controls */
        .top-right {
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        .zoom-btn {
            width: 36px; height: 36px;
            background: var(--button-bg);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .zoom-btn:hover { background: var(--button-hover); }

        /* Bottom Right Upper: Legend */
        .bottom-right-upper {
            bottom: 220px; 
            right: 20px;
            width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Bottom Right Lower: Controls */
        .bottom-right-lower {
            bottom: 20px;
            right: 20px;
            width: 200px;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-light);
            padding-bottom: 8px;
            margin-bottom: 12px;
        }
        .sub-header { 
            font-size: 12px; 
            font-weight: 600; 
            color: var(--text-secondary); 
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            margin-bottom: 8px; 
        }

        /* Legend Items */
        .legend-list { display: flex; flex-direction: column; gap: 6px; margin-bottom: 16px; }
        .legend-item { display: flex; align-items: center; gap: 10px; font-size: 12px; }
        .swatch { 
            width: 18px; height: 18px; 
            border-radius: 4px; 
            border: 1px solid var(--border-light);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            flex-shrink: 0; 
        }

        /* Toggles */
        .toggle-row { display: flex; flex-direction: column; gap: 6px; margin-bottom: 12px; }
        .toggle-row label { font-size: 12px; font-weight: 500; color: var(--text-secondary); }
        .switch { position: relative; width: 44px; height: 24px; display: inline-block; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; bottom: 0; left: 0; right: 0; background-color: #2b3137; transition: .3s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: var(--bg-secondary); transition: .3s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent); }
        input:checked + .slider:before { transform: translateX(20px); }

        /* Buttons */
        .grid-buttons { display: flex; gap: 8px; }
        .btn-action {
            flex: 1;
            background: var(--button-bg);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn-action:hover { background: var(--button-hover); }

        /* Context Menu */
        #context-menu {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            box-shadow: var(--card-shadow);
            z-index: 2000;
            padding: 4px 0;
            min-width: 140px;
        }
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-primary);
            transition: background 0.2s;
        }
        .context-menu-item:hover { background: var(--button-hover); }

        /* Chat Widget Styles */
        .chat-trigger {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 14px rgba(0,0,0,0.25);
            z-index: 2000;
            transition: transform 0.2s;
        }
        .chat-trigger:hover { transform: scale(1.1); }

        .chat-container {
            position: fixed;
            bottom: 80px;
            left: 20px;
            width: 350px;
            height: 500px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-radius: 16px;
            border: 1px solid var(--border-light);
            z-index: 2000;
            background: var(--bg-secondary);
        }
        .chat-header {
            background: #8b5cf6; /* Updated to Purple */
            color: white;
            padding: 16px;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chat-main {
            flex: 1;
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .api-key-box {
            padding: 8px 16px;
            background: var(--button-bg);
            border-bottom: 1px solid var(--border-light);
        }
        .api-input {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 4px;
            padding: 6px 10px;
            color: var(--text-primary);
            font-size: 12px;
            outline: none;
            box-sizing: border-box;
        }

        .messages-area {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .message-bubble { 
            padding: 10px 14px; 
            border-radius: 12px; 
            font-size: 14px; 
            line-height: 1.5; 
            max-width: 85%; 
        }
        .message-bubble.ai { 
            background: #1f2937; 
            border: 1px solid var(--border-light); 
            color: var(--text-primary); 
            align-self: flex-start; 
            border-bottom-left-radius: 2px;
        }
        .message-bubble.user { 
            background: #6366f1; 
            color: white; 
            align-self: flex-end; 
            border-bottom-right-radius: 2px;
        }

        .chat-input-bar {
            padding: 12px;
            border-top: 1px solid var(--border-light);
            display: flex;
            gap: 8px;
            background: var(--bg-secondary);
        }
        .chat-field {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border-light);
            border-radius: 20px;
            padding: 10px 16px;
            color: var(--text-primary);
            font-size: 14px;
            outline: none;
        }
        .send-icon-btn {
            width: 38px;
            height: 38px;
            background: #6366f1;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
        }

        .fade-slide-enter-active, .fade-slide-leave-active { transition: all 0.3s ease; }
        .fade-slide-enter-from, .fade-slide-leave-to { opacity: 0; transform: translateY(20px) scale(0.9); }

        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-thumb { background: #30363d; border-radius: 10px; }
    </style>
</head>
<body>
    <div id="app">
        <!-- Canvas -->
        <canvas ref="canvasEl" 
            @mousedown="handleMouseDown" 
            @mousemove="handleMouseMove" 
            @mouseup="handleMouseUp" 
            @wheel.prevent="handleWheel"
            @click="handleClick"
            @contextmenu.prevent="handleRightClick">
        </canvas>

        <!-- Context Menu -->
        <div id="context-menu" v-if="contextMenu.visible" :style="{ top: contextMenu.y + 'px', left: contextMenu.x + 'px' }">
            <template v-if="isolatedNode && isolatedNode.id === contextMenu.node?.id">
                 <div class="context-menu-item" @click="cancelIsolation">Cancel Isolation</div>
            </template>
            <template v-else>
                <div class="context-menu-item" @click="isolateNode">Isolate Node</div>
            </template>
            <div class="context-menu-item" @click="copyLabel">Copy Label</div>
        </div>
        
        <!-- Header -->
        <div class="ui-card top-center">
            <h1>{{ metadata.title || 'Directed Graph with Anchors' }}</h1>
            <p>{{ metadata.nodeCount }} nodes ({{ legend.nodeTypes.filter(t => t.label !== 'Anchor').length }} types), {{ metadata.edgeCount }} edges</p>
        </div>

        <!-- Zoom Controls -->
        <div class="ui-card top-right">
            <button class="zoom-btn" @click="changeZoom(1.1)">+</button>
            <button class="zoom-btn" @click="changeZoom(0.9)">-</button>
            <button class="zoom-btn" @click="resetCamera">⌂</button>
        </div>

        <!-- Legend Card (Fixed Bottom Right Upper) -->
        <div class="ui-card bottom-right-upper">
            <div class="section-title">Legend</div>
            <div class="sub-header">NODE TYPES</div>
            <div class="legend-list">
                <div v-for="t in legend.nodeTypes.filter(t => t.label !== 'Anchor')" :key="t.label" class="legend-item">
                    <div class="swatch" :style="{ background: t.color }"></div>
                    <span>{{ t.label }}</span>
                </div>
            </div>
            <div class="sub-header" v-if="legend.edgeTypes && legend.edgeTypes.length > 0">EDGE TYPES</div>
            <div class="legend-list" v-if="legend.edgeTypes && legend.edgeTypes.length > 0">
                <div v-for="t in legend.edgeTypes" :key="t.label" class="legend-item">
                    <div class="swatch" :style="{ background: t.color, height: '4px', marginTop: '7px' }"></div>
                    <span>{{ t.label }}</span>
                </div>
            </div>
            <div class="sub-header">SPECIAL NODES</div>
            <div class="legend-item">
                <div class="swatch" style="background: rgba(239, 68, 68, 0.9);"></div>
                <span>Anchor Nodes</span>
            </div>
        </div>

        <!-- Controls Card (Fixed Bottom Right Lower) -->
        <div class="ui-card bottom-right-lower">
            <div class="toggle-row">
                <label>Show Labels</label>
                <label class="switch">
                    <input type="checkbox" v-model="showLabels" @change="render">
                    <span class="slider"></span>
                </label>
            </div>
             <!-- Export -->
            <div class="toggle-row">
                <label>Export</label>
                <div class="grid-buttons">
                    <button class="btn-action" @click="savePDF">PDF</button>
                    <button class="btn-action" @click="savePNG">PNG</button>
                </div>
            </div>
            <!-- Navigation -->
            <div class="toggle-row">
                <label>Navigation</label>
                <div class="grid-buttons">
                    <button class="btn-action" @click="nav('http://localhost:3000/import')">Upload</button>
                    <button class="btn-action" @click="nav('http://localhost:3000')">Annotation</button>
                </div>
            </div>
        </div>

        <!-- Chat -->
        <div class="chat-trigger" @click="openChat = !openChat">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
        </div>

        <transition name="fade-slide">
            <div v-if="openChat" class="chat-container">
                <div class="chat-header">
                    <span>Pattern Analyser</span>
                    <span @click="openChat = false" style="cursor: pointer; opacity: 0.8;">×</span>
                </div>
                <div class="chat-main">
                    <div class="api-key-box">
                        <input type="password" v-model="geminiApiKey" class="api-input" placeholder="Enter Gemini API Key">
                    </div>
                    <div class="messages-area" ref="scrollRef">
                        <div v-for="m in chats" :key="m.id" :class="['message-bubble', m.role]">
                            {{ m.text }}
                        </div>
                    </div>
                </div>
                <div class="chat-input-bar">
                    <input v-model="query" @keyup.enter="doChat" class="chat-field" placeholder="Ask about this pattern...">
                    <button class="send-icon-btn" @click="doChat">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    </button>
                </div>
            </div>
        </transition>
    </div>

    <script>
        const GRAPH_DATA = null;

        const { createApp, ref, onMounted, nextTick, reactive } = Vue;

        class LayoutEngine {
            static computeLayout(nodes, edges) {
                const adj = {};
                const degree = {};
                nodes.forEach(n => { adj[n.id] = []; degree[n.id] = 0; });
                edges.forEach(e => {
                    if (adj[e.source] && adj[e.target]) {
                        adj[e.source].push(e.target);
                        if (!adj[e.target].includes(e.source)) adj[e.target].push(e.source);
                        degree[e.source]++; degree[e.target]++;
                    }
                });
                let centerNodeId = nodes[0]?.id;
                let maxDeg = -1;
                for (let id in degree) { if(degree[id] > maxDeg) { maxDeg = degree[id]; centerNodeId = id; } }
                
                const layers = {};
                const q = [{id: centerNodeId, d: 0}];
                const visited = new Set([centerNodeId]);
                while(q.length) {
                    const cur = q.shift();
                    if(!layers[cur.d]) layers[cur.d] = [];
                    layers[cur.d].push(cur.id);
                    (adj[cur.id] || []).forEach(nId => {
                        if(!visited.has(nId)) {
                            visited.add(nId);
                            q.push({id: nId, d: cur.d+1});
                        }
                    });
                }
                const pos = {};
                const baseRad = 250;
                Object.keys(layers).forEach(d => {
                    const depth = parseInt(d);
                    const levelNodes = layers[d];
                    const radius = depth * baseRad;
                    levelNodes.forEach((nid, i) => {
                        const angle = (2 * Math.PI * i) / levelNodes.length;
                        pos[nid] = { x: radius * Math.cos(angle), y: radius * Math.sin(angle) };
                    });
                });
                nodes.forEach(n => {
                    if(pos[n.id]) { n.x = pos[n.id].x; n.y = pos[n.id].y; }
                    else { n.x = 0; n.y = 0; }
                });
            }
        }

        const generateColor = (seed) => {
            const hue = (seed * 137.508) % 360;
            const saturation = 50 + (seed * 19) % 25; 
            const lightness = 65 + (seed * 13) % 20; 
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        };

        createApp({
            setup() {
                const canvasEl = ref(null);
                const scrollRef = ref(null);
                const openChat = ref(false);
                const showLabels = ref(true);
                const query = ref('');
                const geminiApiKey = ref('');
                const isolatedNode = ref(null);
                
                const raw = GRAPH_DATA || {
                    metadata: { title: "No Data", nodeCount: 0, edgeCount: 0 },
                    nodes: [], edges: [], legend: { nodeTypes: [], edgeTypes: [] }
                };

                // Generate Colors and Legend if missing
                if (raw.nodes.length > 0 && raw.legend.nodeTypes.length === 0) {
                    const types = new Set();
                    raw.nodes.forEach(n => { 
                        if (n.label && !n.anchor && n.label !== 'Anchor') types.add(n.label); 
                    });
                    let seed = 0;
                    types.forEach(t => {
                        raw.legend.nodeTypes.push({ label: t, color: generateColor(seed++) });
                    });
                }

                // Auto-generate Edge Legend if missing
                if (raw.edges.length > 0 && (!raw.legend.edgeTypes || raw.legend.edgeTypes.length === 0)) {
                    if (!raw.legend.edgeTypes) raw.legend.edgeTypes = [];
                    const eTypes = new Set();
                    raw.edges.forEach(e => { if (e.label) eTypes.add(e.label); });
                    let seed = 100; 
                    eTypes.forEach(t => {
                        raw.legend.edgeTypes.push({ label: t, color: '#3b82f6' }); 
                    });
                }

                if (raw.nodes.length > 0) LayoutEngine.computeLayout(raw.nodes, raw.edges);

                const metadata = ref(raw.metadata);
                const legend = ref(raw.legend);
                const chats = ref([{ id: 1, role: 'ai', text: "Hello! I'm your Pattern Analyst. I can help you understand the topological structure of this motif. Ask me anything!" }]);
                
                const contextMenu = reactive({ visible: false, x: 0, y: 0, node: null });

                let ctx;
                let cam = { x: 0, y: 0, k: 1 };
                let isDragging = false;
                let draggedNode = null;
                let lastMouse = { x: 0, y: 0 };
                let hoveredNode = null;
                let selectedNode = null;

                const getWorldPos = (ex, ey) => {
                    const canvas = canvasEl.value;
                    const wx = (ex - canvas.width/2 - cam.x) / cam.k;
                    const wy = (ey - canvas.height/2 - cam.y) / cam.k;
                    return { x: wx, y: wy };
                };

                const getNodeAt = (wx, wy) => {
                    for (let i = raw.nodes.length - 1; i >= 0; i--) {
                        const n = raw.nodes[i];
                        const r = 50; // Base Radius
                        // Check if within bounds
                        if (n.anchor) {
                            if (wx >= n.x - r * 1.2 && wx <= n.x + r * 1.2 &&
                                wy >= n.y - r * 1.2 && wy <= n.y + r * 1.2) return n;
                        } else {
                            const dist = Math.sqrt((n.x - wx)**2 + (n.y - wy)**2);
                            if (dist < r) return n;
                        }
                    }
                    return null;
                };

                const getNodeEdgeIntersection = (node, x0, y0, x1, y1) => {
                    // Returns the intersection point from (x0, y0) to (x1, y1) with the node's border
                    const r = 50; 
                    if (node.anchor) {
                        // Square intersection
                        const size = r * 1.2; 
                        const cx = node.x, cy = node.y;
                        const dx = x1 - x0, dy = y1 - y0;
                        let tMin = Infinity, ix = cx, iy = cy;
                        const borders = [
                            { x: cx - size, y: null }, { x: cx + size, y: null },
                            { x: null, y: cy - size }, { x: null, y: cy + size }
                        ];
                        for (const border of borders) {
                            let t;
                            if (border.x !== null) {
                                if (dx !== 0) {
                                    t = (border.x - x0) / dx;
                                    const y = y0 + t * dy;
                                    if (t > 0 && y >= cy - size && y <= cy + size && t < tMin) {
                                        tMin = t; ix = border.x; iy = y;
                                    }
                                }
                            } else {
                                if (dy !== 0) {
                                    t = (border.y - y0) / dy;
                                    const x = x0 + t * dx;
                                    if (t > 0 && x >= cx - size && x <= cx + size && t < tMin) {
                                        tMin = t; ix = x; iy = border.y;
                                    }
                                }
                            }
                        }
                        return { x: ix, y: iy };
                    } else {
                        // Circle intersection
                        const dx = x1 - x0, dy = y1 - y0;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist === 0) return { x: node.x, y: node.y };
                        return {
                            x: node.x + (dx / dist) * r,
                            y: node.y + (dy / dist) * r
                        };
                    }
                };

                const render = () => {
                    const canvas = canvasEl.value;
                    if (!canvas || !ctx) return;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.save();
                    ctx.translate(canvas.width/2 + cam.x, canvas.height/2 + cam.y);
                    ctx.scale(cam.k, cam.k);

                    const iso = isolatedNode.value;

                    // 1. Edges
                    const baseLineWidth = 2; // Original code used 3/scale, but 2 is cleaner at default
                    
                    raw.edges.forEach(e => {
                        const s = raw.nodes.find(n => n.id === e.source);
                        const t = raw.nodes.find(n => n.id === e.target);
                        if (!s || !t) return;

                        let isDimmed = false;
                        if (iso) {
                            const connected = (s.id === iso.id || t.id === iso.id);
                            if (!connected) isDimmed = true;
                        }

                        let edgeColor = '#3b82f6';
                        let lineWidth = baseLineWidth;

                        if (isDimmed) {
                            ctx.globalAlpha = 0.2;
                            edgeColor = '#555';
                        } else {
                            ctx.globalAlpha = 0.8;
                            // Highlight if connected to dragged/selected
                            if (draggedNode && (s.id === draggedNode.id || t.id === draggedNode.id)) {
                                lineWidth = 4;
                                ctx.globalAlpha = 1.0;
                            } else if (selectedNode && (s.id === selectedNode.id || t.id === selectedNode.id)) {
                                lineWidth = 3;
                                ctx.globalAlpha = 0.9;
                            }
                        }

                        ctx.strokeStyle = edgeColor;
                        ctx.fillStyle = edgeColor;
                        ctx.lineWidth = lineWidth;

                        // Precise Intersection
                        const start = getNodeEdgeIntersection(s, s.x, s.y, t.x, t.y);
                        const end = getNodeEdgeIntersection(t, t.x, t.y, s.x, s.y);

                        ctx.beginPath();
                        ctx.moveTo(start.x, start.y);
                        ctx.lineTo(end.x, end.y);
                        ctx.stroke();

                        if (e.directed) {
                            const dx = end.x - start.x;
                            const dy = end.y - start.y;
                            const len = Math.sqrt(dx*dx + dy*dy);
                            const ux = dx/len;
                            const uy = dy/len;
                            const arrowSize = 12;
                            // Arrow
                            ctx.beginPath();
                            const angle = Math.PI/6;
                            const x1 = end.x - arrowSize * (ux * Math.cos(angle) - uy * Math.sin(angle));
                            const y1 = end.y - arrowSize * (uy * Math.cos(angle) + ux * Math.sin(angle));
                            const x2 = end.x - arrowSize * (ux * Math.cos(-angle) - uy * Math.sin(-angle));
                            const y2 = end.y - arrowSize * (uy * Math.cos(-angle) + ux * Math.sin(-angle));
                            ctx.moveTo(end.x, end.y);
                            ctx.lineTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        if (showLabels.value && e.label && e.label !== 'default' && !isDimmed) {
                            drawLabelBox(e.label, (s.x+t.x)/2, (s.y+t.y)/2, 8, false);
                        }
                    });

                    // 2. Nodes
                    raw.nodes.forEach(n => {
                        let isDimmed = false;
                        if (iso) {
                            const isNeighbor = raw.edges.some(e => 
                                (e.source === iso.id && e.target === n.id) || 
                                (e.target === iso.id && e.source === n.id)
                            );
                            if (n.id !== iso.id && !isNeighbor) isDimmed = true;
                        }

                        const isAnchor = n.anchor;
                        const baseRadius = 50; 
                        
                        // State Logic
                        const isHovered = hoveredNode && hoveredNode.id === n.id;
                        const isSelected = selectedNode && selectedNode.id === n.id;
                        const isDragged = draggedNode && draggedNode.id === n.id;

                        let radius = baseRadius;
                        let size = baseRadius * 1.2; // For anchor square
                        let borderColor = 'transparent'; // Remove default black border
                        let lineWidth = 0;
                        let opacity = 1.0;

                        if (isDimmed) opacity = 0.2;

                        if (isDragged) {
                            radius *= 1.1; size *= 1.1;
                            borderColor = 'rgba(59, 130, 246, 0.8)';
                            lineWidth = 4;
                            ctx.shadowColor = 'rgba(59, 130, 246, 0.4)';
                            ctx.shadowBlur = 10;
                        } else if (isSelected) {
                            radius *= 1.05; size *= 1.05;
                            borderColor = 'rgba(59, 130, 246, 0.8)'; // Blue border
                            lineWidth = 3;
                        } else if (isHovered) {
                            radius *= 1.02; size *= 1.02;
                            borderColor = 'rgba(59, 130, 246, 0.6)'; // Blue border
                            lineWidth = 3;
                        }

                        ctx.save();
                        ctx.globalAlpha = opacity;
                        
                        const fill = isAnchor ? 'rgba(239, 68, 68, 0.9)' : 
                                    (legend.value.nodeTypes.find(t => t.label === n.label)?.color || 'rgba(96, 165, 250, 0.8)');
                        
                        ctx.fillStyle = fill;
                        ctx.strokeStyle = borderColor;
                        ctx.lineWidth = lineWidth;

                        ctx.beginPath();
                        if (isAnchor) {
                            ctx.rect(n.x - size, n.y - size, size*2, size*2);
                        } else {
                            ctx.arc(n.x, n.y, radius, 0, Math.PI * 2);
                        }
                        ctx.fill();
                        if (lineWidth > 0) ctx.stroke(); // Only stroke if we have a border
                        
                        ctx.restore();

                        if (showLabels.value && !isDimmed) {
                            const labelText = `label: ${n.label || 'Node'}`;
                            drawLabelBox(labelText, n.x, n.y, 10, true);
                        }
                    });
                    ctx.restore();
                };

                const drawLabelBox = (text, x, y, fontSize, isNode) => {
                    ctx.save();
                    ctx.font = `${fontSize}px Inter, sans-serif`;
                    const metrics = ctx.measureText(text);
                    const w = metrics.width;
                    const h = fontSize;
                    const p = 4;
                    
                    ctx.fillStyle = '#FFFFFF'; 
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
                    ctx.lineWidth = 1;

                    ctx.beginPath();
                    ctx.roundRect(x - w/2 - p, y - h/2 - p, w + p*2, h + p*2, 4);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = '#000000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(text, x, y + 1);
                    ctx.restore();
                };

                // Mouse Event Handlers
                const handleMouseDown = (e) => {
                    if (e.button !== 0) return;
                    contextMenu.visible = false;
                    const { x, y } = getWorldPos(e.clientX, e.clientY);
                    const node = getNodeAt(x, y);
                    if (node) {
                        draggedNode = node;
                        selectedNode = node; // Auto-select on click/drag
                    } else {
                        isDragging = true;
                        selectedNode = null; // Deselect if clicking empty space
                    }
                    lastMouse = { x: e.clientX, y: e.clientY };
                    render();
                };

                const handleMouseMove = (e) => {
                    const { x, y } = getWorldPos(e.clientX, e.clientY);
                    if (draggedNode) {
                        draggedNode.x = x;
                        draggedNode.y = y;
                        canvasEl.value.style.cursor = 'grabbing';
                    } else if (isDragging) {
                        cam.x += (e.clientX - lastMouse.x);
                        cam.y += (e.clientY - lastMouse.y);
                        canvasEl.value.style.cursor = 'grabbing';
                    } else {
                        const node = getNodeAt(x, y);
                        hoveredNode = node;
                        canvasEl.value.style.cursor = node ? 'pointer' : 'grab';
                    }
                    lastMouse = { x: e.clientX, y: e.clientY };
                    render();
                };

                const handleClick = (e) => {
                    // Handled in mousedown mostly, but ensures click logic is clean
                };

                const handleMouseUp = () => { draggedNode = null; isDragging = false; render(); };
                const handleWheel = (e) => {
                    const f = e.deltaY > 0 ? 0.9 : 1.1;
                    cam.k *= f;
                    render();
                };
                
                const handleRightClick = (e) => {
                    const { x, y } = getWorldPos(e.clientX, e.clientY);
                    const node = getNodeAt(x, y);
                    if (node) {
                        contextMenu.visible = true;
                        contextMenu.x = e.clientX;
                        contextMenu.y = e.clientY;
                        contextMenu.node = node;
                        selectedNode = node; // Also select on right click
                        render();
                    }
                };

                // Context Actions
                const isolateNode = () => {
                    isolatedNode.value = contextMenu.node;
                    contextMenu.visible = false;
                    render();
                };
                const cancelIsolation = () => {
                    isolatedNode.value = null;
                    contextMenu.visible = false;
                    render();
                };
                const copyLabel = () => {
                   if (contextMenu.node && contextMenu.node.label) {
                       navigator.clipboard.writeText(contextMenu.node.label);
                       alert("Label copied: " + contextMenu.node.label);
                   }
                   contextMenu.visible = false;
                };

                const changeZoom = (f) => { cam.k *= f; render(); };
                const resetCamera = () => { cam = { x: 0, y: 0, k: 1 }; render(); };
                
                const doChat = async () => {
                    const t = query.value.trim();
                    if (!t) return;
                    chats.value.push({ id: Date.now(), role: 'user', text: t });
                    query.value = '';
                    nextTick(() => scrollRef.value.scrollTop = scrollRef.value.scrollHeight);
                    try {
                        const res = await fetch(`http://localhost:${GRAPH_DATA?.CHAT_PORT || 9002}/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: t, graph_data: raw, api_key: geminiApiKey.value })
                        });
                        const data = await res.json();
                        chats.value.push({ id: Date.now(), role: 'ai', text: data.response || "No response." });
                    } catch (e) {
                         chats.value.push({ id: Date.now(), role: 'ai', text: "Error connecting to Pattern Analyst." });
                    }
                    nextTick(() => scrollRef.value.scrollTop = scrollRef.value.scrollHeight);
                };

                const savePDF = () => { const doc = new window.jspdf.jsPDF('l', 'px', [canvasEl.value.width, canvasEl.value.height]); doc.addImage(canvasEl.value.toDataURL('image/png'), 'PNG', 0, 0, canvasEl.value.width, canvasEl.value.height); doc.save('graph.pdf'); };
                const savePNG = () => { const l = document.createElement('a'); l.download='graph.png'; l.href=canvasEl.value.toDataURL(); l.click(); };
                const nav = (u) => window.open(u, '_blank');

                onMounted(() => {
                    canvasEl.value.width = window.innerWidth;
                    canvasEl.value.height = window.innerHeight;
                    ctx = canvasEl.value.getContext('2d');
                    window.addEventListener('resize', () => {
                        canvasEl.value.width = window.innerWidth;
                        canvasEl.value.height = window.innerHeight;
                        render();
                    });
                    render();
                });

                return {
                    canvasEl, scrollRef, openChat, showLabels, chats, query, geminiApiKey, 
                    metadata, legend, contextMenu, isolatedNode,
                    handleMouseDown, handleMouseMove, handleMouseUp, handleWheel, handleRightClick, handleClick,
                    isolateNode, cancelIsolation, copyLabel, changeZoom, resetCamera, doChat, savePDF, savePNG, nav, render
                };
            }
        });
    </script>
</body>
</html>